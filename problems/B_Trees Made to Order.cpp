b'/*\nB: Trees Made to Order\nhttp://cxsjsx.openjudge.cn/contest1788/B/\n\n\n\xe6\x8f\x8f\xe8\xbf\xb0\nWe can number binary trees using the following scheme: The empty tree is numbered 0.The single-node tree is numbered 1.All binary trees having m nodes have numbers less than all those having m+1 nodes.Any binary tree having m nodes with left and right subtrees L and R is numbered n such that all trees having m nodes numbered > n have either Left subtrees numbered higher than L, or A left subtree = L and a right subtree numbered higher than R.The first 10 binary trees and tree number 20 in this sequence are shown below:Your job for this problem is to output a binary tree when given its order number.\n\xe8\xbe\x93\xe5\x85\xa5\nInput consists of multiple problem instances. Each instance consists of a single integer n, where 1 <= n <= 500,000,000. A value of n = 0 terminates input. (Note that this means you will never have to output the empty tree.)\n\xe8\xbe\x93\xe5\x87\xba\nFor each problem instance, you should output one line containing the tree corresponding to the order number for that instance. To print out the tree, use the following scheme:A tree with no children should be output as X.A tree with left and right subtrees L and R should be output as (L\')X(R\'), where L\' and R\' are the representations of L and R.  If L is empty, just output X(R\').  If R is empty, just output (L\')X.\n\xe6\xa0\xb7\xe4\xbe\x8b\xe8\xbe\x93\xe5\x85\xa5\n1\r\n20\r\n31117532\r\n0\n\xe6\xa0\xb7\xe4\xbe\x8b\xe8\xbe\x93\xe5\x87\xba\nX\r\n((X)X(X))X\r\n(X(X(((X(X))X(X))X(X))))X(((X((X)X((X)X)))X)X)\n\xe6\x9d\xa5\xe6\xba\x90\nEast Central North America 2001\n\n*/\n\n#include<iostream>\r\nusing namespace std;\r\nlong long f[20],s[20];\r\nvoid init()\r\n{\r\n int i,m;\r\n long long sum;\r\n f[0]=1;\r\n f[1]=1;\r\n for(m=2;m<20;m++)\r\n {\r\n  f[m]=0;\r\n  for(i=0;i<m;i++)\r\n   f[m]+=f[i]*f[m-1-i];\r\n }\r\n sum=0;\r\n s[0]=1;\r\n for(i=1;i<20;i++)\r\n {\r\n  sum+=f[i];\r\n  s[i]=sum;\r\n }\r\n}\r\nvoid Search(long long n,int r)\r\n{\r\n long long sum=0;\r\n int i;\r\n for(i=0;i<r;i++)\r\n {\r\n  sum+=f[i]*f[r-1-i];\r\n  if(n<=sum)\r\n   break;\r\n }\r\n sum-=f[i]*f[r-1-i];\r\n n-=sum;\r\n if(i!=0)//\xe5\xa6\x82\xe6\x9e\x9c\xe5\xb7\xa6\xe5\xad\x90\xe6\xa0\x91\xe9\x9d\x9e\xe7\xa9\xba\r\n {\r\n  printf("(");\r\n  if(n%f[r-1-i]==0)\r\n   Search(n/f[r-1-i],i);\r\n  else\r\n   Search(n/f[r-1-i]+1,i);\r\n  printf(")");\r\n }\r\n printf("X");\r\n if(i!=r-1)//\xe5\xa6\x82\xe6\x9e\x9c\xe5\x8f\xb3\xe5\xad\x90\xe6\xa0\x91\xe9\x9d\x9e\xe7\xa9\xba\r\n {\r\n  printf("(");\r\n  if(n%f[r-1-i]==0)\r\n   Search(f[r-1-i],r-1-i);\r\n  else\r\n   Search(n%f[r-1-i],r-1-i);\r\n  printf(")");\r\n }\r\n}\r\nint main()\r\n{\r\n long long n;\r\n int r;\r\n init();\r\n while(scanf("%lld",&n)!=EOF)\r\n {\r\n  if(n==0)\r\n   break;\r\n  for(r=1;r<20;r++)\r\n  {\r\n   if(n==s[r])\r\n    break;\r\n   if(n>s[r-1]&&n<s[r])\r\n    break;\r\n  }\r\n  n-=s[r-1];\r\n  Search(n,r);\r\n  printf("\\n");\r\n }\r\n}\r\n'
